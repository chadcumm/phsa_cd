1)translate phsa_lib_logging               go
;*** Generated by TRANSLATE, verify before re-including (Debug:N,Optimize:Y,DiffEnd:N,Rdb:N) ***
DROP PROGRAM phsa_lib_logging :dba GO
CREATE PROGRAM phsa_lib_logging :dba
 IF (NOT (validate (logging_lib_loaded ) ) )
  RECORD phsa_lib_logging_entries (
    1 log_entry_node = vc
    1 log_session_id = f8
    1 log_session_start_ts = vc
    1 qual [* ]
      2 log_entry = vc
      2 log_session_entry_seq = i4
      2 log_entry_timestamp = vc
      2 log_entry_level = i2
      2 log_entry_source = vc
      2 log_entry_subroutine = vc
  ) WITH persistscript
  DECLARE logging_lib_loaded = i1 WITH constant (true ) ,persistscript
  DECLARE log_session_id = f8 WITH persistscript
  DECLARE oeneventname = vc WITH constant ("OENScript" ) ,persistscript
  DECLARE log_err_level = i1 WITH constant (0 ) ,persistscript
  DECLARE log_wrn_level = i1 WITH constant (1 ) ,persistscript
  DECLARE log_inf_level = i1 WITH constant (2 ) ,persistscript
  DECLARE log_aud_level = i1 WITH constant (3 ) ,persistscript
  DECLARE log_dbg_level = i1 WITH constant (4 ) ,persistscript
  DECLARE msgviewloggingenabled = i1 WITH noconstant (false ) ,persistscript
  DECLARE dbloggingenabled = i1 WITH noconstant (false ) ,persistscript
  DECLARE usingoenhandle = i1 WITH noconstant (false ) ,persistscript
  DECLARE log_handle = i4 WITH noconstant (0 ) ,persistscript
  DECLARE log_status = i4 WITH noconstant (0 ) ,persistscript
  DECLARE log_event = vc WITH noconstant ("" ) ,persistscript
  DECLARE phsa_lib_log_newalloc = i4 WITH constant (100 ) ,persistscript
  DECLARE phsa_lib_log_curalloc = i4 WITH noconstant (0 ) ,persistscript
  DECLARE phsa_lib_log_cnt = i4 WITH noconstant (0 ) ,persistscript
  DECLARE haveloggederror = i1 WITH noconstant (false ) ,persistscript
  IF (NOT (validate (echo_enabled ) ) )
   DECLARE echo_enabled = i1 WITH noconstant (false ) ,persistscript
   IF ((substring (1 ,1 ,curdomain ) != "P" ) )
    SET echo_enabled = true
   ENDIF
  ENDIF
  IF (NOT (validate (tracelevel ) ) )
   DECLARE tracelevel = i1 WITH noconstant (2 ) ,persistscript
  ENDIF
 ENDIF
 SUBROUTINE  (settracelevel (tl =vc ,lognewlevel =i1 (value ,true ) ) =null WITH copy )
  DECLARE logentry = vc WITH protect
  CASE (trim (cnvtlower (tl ) ,3 ) )
   OF "low" :
    SET tracelevel = log_dbg_level
    SET logentry = "Trace level set to LOW"
   OF "mid" :
    SET tracelevel = log_aud_level
    SET logentry = "Trace level set to MID"
   OF "high" :
    SET tracelevel = log_inf_level
    SET logentry = "Trace level set to HIGH"
   ELSE
    SET tracelevel = log_inf_level
    SET logentry = "Trace level set to default (HIGH)"
  ENDCASE
  IF (lognewlevel )
   CALL loginfomsg (logentry )
  ENDIF
 END ;Subroutine
 SUBROUTINE  (enableecho (null ) =null WITH copy )
  SET echo_enabled = true
 END ;Subroutine
 SUBROUTINE  (enablemsgviewlogging (log_src =vc ) =i1 WITH copy )
  IF (NOT (msgviewloggingenabled ) )
   IF ((log_event < " " ) )
    SET log_event = log_src
   ENDIF
   IF (validate (oen_log->hsys ) )
    SET log_handle = oen_log->hsys
    SET usingoenhandle = true
   ELSE
    CALL uar_syscreatehandle (log_handle ,log_status )
   ENDIF
   SET msgviewloggingenabled = true
   RETURN (true )
  ELSE
   IF (NOT (usingoenhandle ) )
    CALL logwarnmsg ("log already enabled!" )
   ENDIF
  ENDIF
 END ;Subroutine
 SUBROUTINE  (enabledblogging (log_src =vc ) =i1 WITH copy )
  IF (NOT (dbloggingenabled ) )
   IF ((checkdic ("CUST_PF_DEBUG_LOGGING" ,"T" ,0 ) = 0 ) )
    RETURN (false )
   ENDIF
   SET stat = initrec (phsa_lib_logging_entries )
   SELECT INTO "NL:"
    new_id = seq (cust_phsa_misc_seq ,nextval )
    FROM (dual )
    HEAD REPORT
     log_session_id = new_id
    WITH nocounter
   ;end select
   IF ((log_session_id < 1.0 ) )
    CALL logerrormsg ("ERROR: Could not get a unique ID from CUST_PHSA_MISC_SEQ sequence" )
   ENDIF
   SET phsa_lib_logging_entries->log_session_start_ts = format (systimestamp ,
    "DD-MMM-YYYY HH:MM:SS.CCCCCCCCC;;D" )
   SET phsa_lib_logging_entries->log_entry_node = curnode
   SET phsa_lib_logging_entries->log_session_id = log_session_id
   IF ((log_event < " " ) )
    SET log_event = log_src
   ENDIF
   SET phsa_lib_log_curalloc = phsa_lib_log_newalloc
   CALL alterlist (phsa_lib_logging_entries->qual ,phsa_lib_log_curalloc )
   SET dbloggingenabled = true
   RETURN (true )
  ELSE
   CALL logwarnmsg ("log already enabled!" )
  ENDIF
 END ;Subroutine
 SUBROUTINE  (logerrormsg (msg =vc ) =null WITH copy )
  SET haveloggederror = true
  CALL logmsg (msg ,log_err_level )
 END ;Subroutine
 SUBROUTINE  (logwarnmsg (msg =vc ) =null WITH copy )
  CALL logmsg (msg ,log_wrn_level )
 END ;Subroutine
 SUBROUTINE  (logauditmsg (msg =vc ) =null WITH copy )
  CALL logmsg (msg ,log_aud_level )
 END ;Subroutine
 SUBROUTINE  (loginfomsg (msg =vc ) =null WITH copy )
  CALL logmsg (msg ,log_inf_level )
 END ;Subroutine
 SUBROUTINE  (logdebugmsg (msg =vc ) =null WITH copy )
  CALL logmsg (msg ,log_dbg_level )
 END ;Subroutine
 SUBROUTINE  (logmsg (msg =vc ,level =i1 ,doecho =i1 (value ,echo_enabled ) ) =null WITH copy )
  IF ((level > tracelevel ) )
   RETURN
  ENDIF
  IF (doecho )
   CALL echo (msg )
  ENDIF
  IF (msgviewloggingenabled )
   IF (usingoenhandle )
    CALL uar_sysevent (log_handle ,log_aud_level ,nullterm (oeneventname ) ,nullterm (build2 (
       log_event ,"/" ,msg ) ) )
   ELSE
    CALL uar_sysevent (log_handle ,level ,nullterm (log_event ) ,nullterm (msg ) )
   ENDIF
  ENDIF
  IF (dbloggingenabled )
   CALL adddbloggingentry (msg ,level ,log_event )
  ENDIF
 END ;Subroutine
 SUBROUTINE  (adddbloggingentry (log_entry =vc ,log_entry_level =i1 ,log_entry_source =vc ) =null
  WITH copy )
  SET phsa_lib_log_cnt +=1
  IF ((phsa_lib_log_cnt > phsa_lib_log_curalloc ) )
   SET phsa_lib_log_curalloc +=phsa_lib_log_newalloc
   CALL alterlist (phsa_lib_logging_entries->qual ,phsa_lib_log_curalloc )
  ENDIF
  IF ((textlen (log_entry ) >= 32000 ) )
   SET log_entry = substring (1 ,32000 ,log_entry )
  ENDIF
  SET phsa_lib_logging_entries->qual[phsa_lib_log_cnt ].log_entry = log_entry
  SET phsa_lib_logging_entries->qual[phsa_lib_log_cnt ].log_session_entry_seq = phsa_lib_log_cnt
  SET phsa_lib_logging_entries->qual[phsa_lib_log_cnt ].log_entry_timestamp = format (systimestamp ,
   "DD-MMM-YYYY HH:MM:SS.CCCCCCCCC;;D" )
  SET phsa_lib_logging_entries->qual[phsa_lib_log_cnt ].log_entry_level = log_entry_level
  SET phsa_lib_logging_entries->qual[phsa_lib_log_cnt ].log_entry_source = log_entry_source
 END ;Subroutine
 SUBROUTINE  (echorec (rec =vc (ref ) ) =null WITH copy )
  CALL logrecasjson (rec )
 END ;Subroutine
 SUBROUTINE  (logrecasjson (rec =vc (ref ) ) =null WITH copy )
  IF (echo_enabled )
   CALL echorecord (rec )
  ENDIF
  CALL logmsg (cnvtrectojson (rec ) ,log_dbg_level ,false )
 END ;Subroutine
 SUBROUTINE  (closelogwitherrors (withcommit =i1 (value ,false ) ,alwayslogstatus =i1 (value ,false
   ) ) =i1 WITH copy )
  DECLARE errorslogged = i1 WITH noconstant (haveloggederror ) ,private
  SET haveloggederror = false
  CALL closelog (withcommit ,alwayslogstatus )
  RETURN (errorslogged )
 END ;Subroutine
 SUBROUTINE  (closelog (withcommit =i1 (value ,false ) ,alwayslogstatus =i1 (value ,false ) ) =null
  WITH copy )
  IF (NOT (usingoenhandle ) )
   CALL uar_sysdestroyhandle (log_handle )
  ENDIF
  IF (validate (currentlibstat )
  AND validate (statuses->status )
  AND (checkfun ("GETCURRENTEVENT" ) = 7 ) )
   IF ((currentlibstat > 0 )
   AND (size (statuses->status ,5 ) >= currentlibstat ) )
    IF ((statuses->status[currentlibstat ].status_char IN ("s" ,
    "S" ,
    "z" ,
    "Z" ) ) )
     IF (((phsa_lib_log_cnt ) OR (alwayslogstatus )) )
      CALL loginfomsg (build2 ("STATUS: Program terminated normally. [" ,getcurrentevent (null ) ,
        "]" ) )
     ENDIF
    ELSE
     CALL logerrormsg (build2 ("STATUS: Program terminated in error. [" ,getcurrentevent (null ) ,
       "]" ) )
    ENDIF
   ENDIF
  ENDIF
  IF (dbloggingenabled
  AND phsa_lib_log_cnt )
   IF (checkprg ("PHSA_WRITE_LOGS" )
   AND (curprog != "PHSA_WRITE_LOGS" ) )
    RECORD rep (
      1 ops_event = vc
      1 status_data
        2 status = c1
        2 subeventstatus [1 ]
          3 operationname = c25
          3 operationstatus = c1
          3 targetobjectname = c25
          3 targetobjectvalue = vc
    )
    CALL alterlist (phsa_lib_logging_entries->qual ,phsa_lib_log_cnt )
    SET phsa_lib_log_curalloc = phsa_lib_log_cnt
    SET stat = tdbexecute (5000 ,5000 ,2900401 ,"REC" ,phsa_lib_logging_entries ,"REC" ,rep )
    IF (stat )
     EXECUTE pf_adhoc_email value (build ("[" ,curdomain ,"/PHSA_LIB_LOGGING] ERROR OCCURRED" ) ) ,
     "Please investigate" ,
     "0"
    ENDIF
   ELSE
    CALL logwarnmsg ("Using standard logging committal process." )
    CALL addtologgingtable (withcommit )
   ENDIF
  ENDIF
  SET log_session_id = 0
  SET phsa_lib_log_cnt = 0
  SET log_event = ""
  SET msgviewloggingenabled = false
  SET dbloggingenabled = false
 END ;Subroutine
 SUBROUTINE  (getandpurgeerrors (writetolog =i1 ) =i1 WITH copy )
  DECLARE errormessage = vc WITH protect
  DECLARE errorcode = i2 WITH protect
  DECLARE errorcount = i2 WITH protect
  SET errorcode = error (errormessage ,0 )
  WHILE ((errorcode != 0 )
  AND (errorcount < 50 ) )
   SET errorcount +=1
   IF (writetolog )
    CALL logerrormsg (errormessage )
   ENDIF
   SET errorcode = error (errormessage ,0 )
  ENDWHILE
  RETURN (errorcount )
 END ;Subroutine
 SUBROUTINE  (addtologgingtable (withcommit =i1 (value ,false ) ) =null WITH copy )
  INSERT FROM (cust_pf_debug_logging c ),
    (dummyt d WITH seq = phsa_lib_log_cnt )
   SET c.log_entry = phsa_lib_logging_entries->qual[d.seq ].log_entry ,
    c.log_session_entry_seq = phsa_lib_logging_entries->qual[d.seq ].log_session_entry_seq ,
    c.log_session_id = phsa_lib_logging_entries->log_session_id ,
    c.log_session_start_ts = cnvttimestamp (phsa_lib_logging_entries->log_session_start_ts ) ,
    c.log_entry_timestamp = cnvttimestamp (phsa_lib_logging_entries->qual[d.seq ].log_entry_timestamp
      ) ,
    c.log_entry_level = phsa_lib_logging_entries->qual[d.seq ].log_entry_level ,
    c.log_entry_source = phsa_lib_logging_entries->qual[d.seq ].log_entry_source ,
    c.log_entry_node = phsa_lib_logging_entries->log_entry_node ,
    c.updt_dt_tm = sysdate ,
    c.updt_applctx = reqinfo->updt_applctx ,
    c.updt_cnt = 0 ,
    c.updt_id = reqinfo->updt_id ,
    c.updt_task = reqinfo->updt_task
   PLAN (d
    WHERE (phsa_lib_logging_entries->qual[d.seq ].log_session_entry_seq > 0 ) )
    JOIN (c )
   WITH nocounter
  ;end insert
  IF (withcommit )
   COMMIT
  ENDIF
 END ;Subroutine
 SUBROUTINE  (getcallingsubroutinename (null ) =c100 WITH copy )
  IF (log_extra_info )
   DECLARE subdepth = i4 WITH noconstant (getcallingsubroutinedepth (null ) ) ,private
   IF (subdepth )
    RETURN (cursub (subdepth ) )
   ELSE
    RETURN ("ROOTPROGRAM" )
   ENDIF
  ELSE
   RETURN ("" )
  ENDIF
 END ;Subroutine
 SUBROUTINE  (getcallingsubroutinedepth (null ) =i4 WITH copy )
  DECLARE num = i4 WITH noconstant (0 ) ,private
  WHILE ((num >= 0 ) )
   SET num +=1
   IF ((((cursub (num ) = " " ) ) OR ((cursub (num ) = "GETCALLINGSUBROUTINEDEPTH" ) )) )
    IF ((num <= 4 ) )
     RETURN (0 )
    ELSE
     RETURN ((num - 4 ) )
    ENDIF
   ENDIF
  ENDWHILE
 END ;Subroutine
#exit_script
END GO
1)

221004:191206 CHAD.CUMMINGS_DVD15              Cost 0.00 Cpu 0.00 Ela 0.01 Dio   0 O0M0R0 P1R0
